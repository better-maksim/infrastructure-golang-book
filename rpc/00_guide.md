# GO RPC 开发指南

## 什么是 RPC

**远程过程调用（Remote Procedure Call，缩写为 RPC)** 是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，比如 Java RMI。

有关RPC的想法至少可以追溯到1976年以“信使报”（Courier）的名义使用。RPC首次在UNIX平台上普及的执行工具程序是SUN公司的RPC（现在叫ONC RPC）。它被用作SUN的NFC的主要部件。ONC RPC今天仍在服务器上被广泛使用。 另一个早期UNIX平台的工具是“阿波罗”计算机网络计算系统（NCS），它很快就用做OSF的分布计算环境（DCE）中的DCE/RPC的基础，并补充了DCOM。

远程过程调用是一个分布式计算的客户端-服务器（Client/Server）的例子，它简单而又广受欢迎。 远程过程调用总是由客户端对服务器发出一个执行若干过程请求，并用客户端提供的参数。执行结果将返回给客户端。 由于存在各式各样的变体和细节差异，对应地派生了各式远程过程调用协议，而且它们并不互相兼容。

为了允许不同的客户端均能访问服务器，许多标准化的 RPC 系统应运而生了。其中大部分采用接口描述语言（Interface Description Language，IDL），方便跨平台的远程过程调用。

## 本地调用的过程

```go
package main
import "fmt"

func add (int a, int b) : int {
	total := a + b 
	return total
}

func main() {
  fmt.println(add(1,2))
}
```

以上面的代码为例，我们要执行一个函数要经历以下过程。

1. 将 1 和 2 压入 add 函数的栈
2. 进入 add 函数，从栈中取出 1 和 2 分别赋值给 a 和 b
3. 执行 a + b 将结果复制给全局的 total 并压入栈中
4. 将栈中的值取出来复制给全局 total

## RPC 调用的执行过程



encode decode

![image-20211207134347727](/Users/guozhu/Library/Application Support/typora-user-images/image-20211207134347727.png)

![来自microsoft](https://doc.rpcx.io/ch0-RPC.gif)

从上图可以看出, RPC 本身是 client-server模型,也是一种 request-response 协议。

有些实现扩展了远程调用的模型，实现了双向的服务调用，但是不管怎样，调用过程还是由一个客户端发起，服务器端提供响应，基本模型没有变化。

服务的调用过程为：

1. client调用client stub，这是一次本地过程调用
2. client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做 marshalling
3. client所在的系统将消息发送给server
4. server的的系统将收到的包传给server stub
5. server stub解包得到参数。 解包也被称作 unmarshalling
6. 最后server stub调用服务过程. 返回结果按照相反的步骤传给client

## 实现一个RPC要面临的各种问题

1. **Call 的 ID 映射** ，我们怎么告诉远程机器我们要调用 add 而不是其他的函数，函数体是直接通过含糊指针来指定的，我们调用 add 编译器就自动会帮我们调用响应的函数指针。但是远程调用过程中，函数指针是不行的，因为两个进程的地址空间是完全不一样的，所以在 RPC 中，所有函数必须有自己的一个 ID，这个 ID 在所有进程中都是唯一确定的。客户端在远程调用时候必须带上这个 ID，我们还需要对这个客户端和服务端维护一个对应表，两者的表不一定需要完全相同，但相同的函数对应的 Call ID 必须相同。当客户端进行远程调用时，需要查一下这个表，找到对应的 Call ID，然后把它给服务端，服务端需要确定客户端调用的函数，来执行相对应的代码。这也就是我们常说**远程方法对象代理**
2. **序列化和反序列化**，客户端把参数如何进行远程传递，在本地跑的时候是栈操作，但是远程调用，客户端和服务端是不同的进程，不能通过内存传递参数，甚至有时候客户端和服务端不是一个语言，这个时候就需要把参数转换成一个字节流，然后传给服务器，再把字节流转乘自己能读取的格式，这个过程就教序列化和反序列化。
3. **网络传输**，远程调用往往用在网络上，客户端服务单通过网络连接的。

上面这些只是刚刚做好了 RPC，还不能称之为一款好的 RPC 框架，一款好的 RPC 框架还要包括以下特性：

- 版本管理
- 超时管理
- 负载均衡
- 优雅关闭
- 服务熔断
- 服务降级
- 限流
- 动态权重

## RPC VS REST API

RPC 的消息传输可以通过 TCP、UDP 或者 HTTP等，所以有时候我们称之为 RPC over TCP、 RPC over HTTP。RPC 通过 HTTP 传输消息的时候和 RESTful的架构是类似的，但是也有不同。

首先我们比较 RPC over HTTP 和 RESTful。

1. RPC 的客户端和服务器端是**紧耦合**的，客户端需要知道调用的过程的名字，过程的参数以及它们的类型、顺序等。一旦服务器更改了过程的实现， 客户端的实现很容易出问题。RESTful基于 http的语义操作资源，参数的顺序一般没有关系，也很容易的通过代理转换链接和资源位置，从这一点上来说，RESTful 更灵活。

2. 它们操作的对象不一样。 RPC 操作的是方法和过程，它要操作的是方法对象。 RESTful 操作的是资源(resource)，而不是方法。

3. RESTful执行的是对资源的操作，增加、查找、修改和删除等,主要是CURD，所以如果你要实现一个特定目的的操作，比如为名字姓张的学生的数学成绩都加上10这样的操作， RESTful的API设计起来就不是那么直观或者有意义。在这种情况下, RPC的实现更有意义，它可以实现一个 `Student.Increment(Name, Score)` 的方法供客户端调用。

![img](https://doc.rpcx.io/restful.jpg)

我们再来比较一下 RPC over TCP 和 RESTful。 如果我们直接使用socket实现 RPC，除了上面的不同外，我们可以获得性能上的优势。

RPC over TCP 可以通过长连接**减少连接的建立所产生的花费**，在调用次数非常巨大的时候(这是目前互联网公司经常遇到的情况,大并发的情况下)，这个花费影响是非常巨大的。 当然 RESTful 也可以通过 keep-alive 实现长连接， 但是它最大的一个问题是它的request-response模型是阻塞的 (http1.0和 http1.1, http 2.0没这个问题)， 发送一个请求后只有等到response 返回才能发送第二个请求 (有些http server实现了pipeling的功能，但不是标配)， RPC的实现没有这个限制。

在当今用户和资源都是大数据大并发的趋势下，一个大规模的公司不可能使用一个单体程序提供所有的功能，微服务的架构模式越来越多的被应用到产品的设计和开发中， 服务和服务之间的通讯也越发的重要， 所以 RPC 不失是一个解决服务之间通讯的好办法， 本书给大家介绍 Go 语言的 RPC的开发实践。

## 参考文档

在这里列举出了本章内容所有的参考。

[GitHub - Bingjian-Zhu/go-grpc-example](https://github.com/Bingjian-Zhu/go-grpc-example)

《GRPC 与云原生应用开发以 Go 和 Java 为例》 中国工信出版集团 

### 推荐阅读

极客时间 
